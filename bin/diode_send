#!/usr/bin/env python3
"""
Send files through unidirectional serial device
"""

import argparse
import hashlib
import logging
import math
import os
import queue
import socket
import time
import threading
import sys

from logging import handlers

DIODE_LOGGER = logging.getLogger('DIODE')
DIODE_LOGGER.setLevel(logging.INFO)
SYSLOG_FORMATTER = logging.Formatter('%(name)s %(levelname)s: %(message)s')
STDERR_FORMATTER = logging.Formatter('%(asctime)s %(levelname)s: %(message)s')
SYSLOG_HANDLER = handlers.SysLogHandler(address='/dev/log')
SYSLOG_HANDLER.setFormatter(SYSLOG_FORMATTER)
STDERR_HANDLER = logging.StreamHandler(sys.stderr)
STDERR_HANDLER.setLevel(logging.DEBUG)
STDERR_HANDLER.setFormatter(STDERR_FORMATTER)
DIODE_LOGGER.addHandler(SYSLOG_HANDLER)
DIODE_LOGGER.addHandler(STDERR_HANDLER)

PARSER = argparse.ArgumentParser(description='Serial device options')
PARSER.add_argument('--target-subnet', type=str, nargs='?', default="10.125.125.255",
                    help='Target subnet broadcast IP')
PARSER.add_argument('--target-port', type=int, nargs='?', default=5005,
                    help='Target port')
PARSER.add_argument('--directory', type=str, nargs='?', required=True,
                    help='directory from which to send files')
PARSER.add_argument('--udp-port', type=int, nargs='?', required=False,
                    help='UDP listen port. Incoming packets will be forwarded through the diode. This enables listening for UDP packets.')
PARSER.add_argument('--udp-host', type=str, nargs='?', required=False, default="127.0.0.1",
                    help='IP address to listen on for UDP packets.')
ARGS = PARSER.parse_args()


CHUNK_SIZE = 940
TARGET_IP = ARGS.target_subnet
TARGET_PORT = int(ARGS.target_port)
SOURCE_DIR = ARGS.directory
DELAY_NEXT_CHUNK = 1800
BATCH_SIZE = 100
RESEND_PACKET = 2
UDP_RESEND_PACKET = 2
SCAN_INTERVAL = 2
STABILITY_CHECK_DELAY = 1

PKG_TYPE_START = 0
PKG_TYPE_DATA = 1
PKG_TYPE_END = 2
PKG_TYPE_UDP = 4

EMPTY_HASH = "00000000000000000000000000000000"

UDP_FWD_QUEUE = queue.Queue()

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

def busy_wait_sleep(cycles: int = DELAY_NEXT_CHUNK):
    """
    time.sleep() is too slow (on OpenBSD). Looping through
    a range can introduce "arbitrarily" short delays. Can be
    replaced by any other function that can introduce delays in
    the range of microseconds.
    """
    for n in range(0, cycles):
        i = n

def get_chunks(filepath: str, batch):
    """
    Read file chunks
    """
    with open(filepath, 'rb') as f:
        f.seek(batch*CHUNK_SIZE*BATCH_SIZE)
        for _ in range(BATCH_SIZE):
            data = f.read(CHUNK_SIZE)
            if not data:
                break
            yield data

def encode_packet(pkg_type: int, count_or_filesize: int, rel_path_hash: str, data_hash: str, data_or_path: str):
    """
    Create packet with fixed length substrings. The input data is not validated. The hases must have a length
    of 32 chars, the count/filesize must not bef longer than 10 chars. The type is only one char.

    packet format:
        packet_type                              = string[0:1]
        count(data/end pkg) / filesize(start pkg) = string[1:11]
        path_hash                                 = string[11:43]
        data_hash                                 = string[43:75]
        data(data pkg) / path(start/end pkg)      = string[75:]

    :param pkg_type: integer with length one which indicates the packet type.
    :param count_or_filesize: the filesize in the start packet or the packet count for data packets. Max 10 chars in length.
    :param rel_path_hash: md5sum of rel path
    :param data_hash: md5sum of data
    :param data_or_path: the relative path of the file in the start packet or a file chunk for data packets.
    """
    if not isinstance(data_or_path, bytes):
        data_or_path = data_or_path.encode('utf-8')
    return str(pkg_type).encode('utf-8')+f"{count_or_filesize:010}".encode('utf-8')+rel_path_hash.encode('utf-8')+data_hash.encode('utf-8')+data_or_path

def send_start_paket(filepath: str, rel_path: str, rel_path_hash: str) -> None:
    """
    Send first paket with meta data
    """
    DIODE_LOGGER.info("Sending file: %s", rel_path)
    filesize = os.path.getsize(filepath)
    start_packet = encode_packet(PKG_TYPE_START, filesize, rel_path_hash, EMPTY_HASH, rel_path)
    for n in range(0, RESEND_PACKET):  # pylint: disable=unused-variable
        sock.sendto(start_packet, (TARGET_IP, TARGET_PORT))
        busy_wait_sleep(DELAY_NEXT_CHUNK)

def send_end_paket(filepath: str, rel_path: str, count: int) -> None:
    """
    Send last paket with final count
    """
    end_packet = encode_packet(PKG_TYPE_END, count, EMPTY_HASH, EMPTY_HASH, rel_path)
    for n in range(0, RESEND_PACKET):  # pylint: disable=unused-variable
        sock.sendto(end_packet, (TARGET_IP, TARGET_PORT))
        busy_wait_sleep(DELAY_NEXT_CHUNK)
    os.remove(filepath)
    DIODE_LOGGER.info("Finished sending file: %s", rel_path)

def send_data_paket(rel_path_hash: str, chunk: bytes, count: int) -> None:
    """
    Send data paket
    """
    data_hash = hashlib.md5(chunk).hexdigest()
    data_packet = encode_packet(PKG_TYPE_DATA, count, rel_path_hash, data_hash, chunk)
    sock.sendto(data_packet, (TARGET_IP, TARGET_PORT))
    busy_wait_sleep(DELAY_NEXT_CHUNK)

def calculate_number_of_batches(filepath):
    """
    Calculate the number of batches. We want to send BATCH_SIZE packets
    in one batch.
    """
    filesize = os.path.getsize(filepath)
    num_chunks = math.ceil(filesize/CHUNK_SIZE)
    return math.ceil(num_chunks/BATCH_SIZE)

def send_file_chunks(filepath: str, rel_path: str) -> None:
    """
    Send a file chunk via UDP along with path and hash

    :param filepath: full path to file
    :param rel_path: relative path to file in relation to watched dir
    """
    rel_path_hash = hashlib.md5(rel_path.encode("utf-8")).hexdigest()
    num_batches = calculate_number_of_batches(filepath)
    send_start_paket(filepath, rel_path, rel_path_hash)
    count = 0
    batch_start_count = 0
    for batch in range(0, num_batches):
        batch_start_count = count
        for resend in range(0, RESEND_PACKET):
            for chunk in get_chunks(filepath, batch):
                if chunk:
                    send_data_paket(rel_path_hash, chunk, count)
                    count += 1
            if resend < RESEND_PACKET - 1:
                count = batch_start_count
    send_end_paket(filepath, rel_path, count)

def is_file_stable(filepath: str, delay: int = STABILITY_CHECK_DELAY) -> bool:
    """Check if file size is stable after waiting for delay."""
    try:
        initial_size = os.path.getsize(filepath)
        time.sleep(delay)
        return os.path.getsize(filepath) == initial_size
    except FileNotFoundError:
        return False

def send_files() -> None:
    """
    Watch directory for new files. Send new files via UDP.
    """
    for root, _, files in os.walk(SOURCE_DIR):
        for file in files:
            full_path = os.path.join(root, file)
            rel_path = os.path.relpath(full_path, SOURCE_DIR)

            if is_file_stable(full_path):
                send_file_chunks(full_path, rel_path)

def forward_udp_packet():
    """
    Forward the content of a UDP packet through the diode.
    """
    while FORWARD_UDP_QUEUE.qsize():
        try:
            packet = FORWARD_UDP_QUEUE.get(False)
        except:
            return


def send_data_wrapper() -> None:
    """
    Wrapper for sending data. Scan for new files and send them. If enabled, forward UDP packets.
    """
    os.makedirs(SOURCE_DIR, exist_ok=True)
    DIODE_LOGGER.info("Watching for new files in: %s", SOURCE_DIR)
    try:
        while True:
            send_files()
            time.sleep(SCAN_INTERVAL)
    except KeyboardInterrupt:
        DIODE_LOGGER.info("Stopped watching")

def receive_udp() -> None:
    """
    Fetch packet from incoming UDP port and queue for diode.
    """
    udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    udp_sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1 * 1024 * 1024)
    udp_sock.bind((ARGS.udp_host, ARGS.udp_port))
    DIODE_LOGGER.info("Forwarding UDP packets arriving at %s:%i", ARGS.udp_host, ARGS.udp_port)
    while True:
        data, ancdata, flags, addr = udp_sock.recvmsg(65535)
        UDP_FWD_QUEUE.put(data)

def forward_udp() -> None:
    """
    Send UDP packet through diode.
    """
    while True:
        data = UDP_FWD_QUEUE.get()
        count = 0
        pkg_id = hashlib.md5(str(time.time_ns()).encode()).hexdigest()
        data_length = f'{len(data):032}'
        for n in range(0, UDP_RESEND_PACKET):
            for i in range(0, len(data), CHUNK_SIZE):
                chunk = data[i:i+CHUNK_SIZE]
                data_packet = encode_packet(PKG_TYPE_UDP, count, data_length, pkg_id, chunk)
                sock.sendto(data_packet, (TARGET_IP, TARGET_PORT))
                count += 1

if __name__ == "__main__":
    threading.Thread(target=send_data_wrapper).start()
    if ARGS.udp_port:
        threading.Thread(target=receive_udp).start()
        threading.Thread(target=forward_udp).start()
